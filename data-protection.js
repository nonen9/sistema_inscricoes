/**
 * Data Protection System
 * Protege dados de produ√ß√£o e previne vazamento de dados de desenvolvimento
 */

const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const crypto = require('crypto');

class DataProtection {
    constructor() {
        this.environment = process.env.NODE_ENV || 'development';
        this.dataPath = process.env.DATA_PATH || './data';
        this.configPath = process.env.CONFIG_PATH || './config';
        this.protectionFile = path.join(this.dataPath, '.environment-lock');
    }

    /**
     * Inicializa o sistema de prote√ß√£o de dados
     */
    async initialize() {
        console.log('üîí Inicializando sistema de prote√ß√£o de dados...');
        console.log('üåç Ambiente atual:', this.environment);
        
        // Garantir que diret√≥rios existam
        await this.ensureDirectories();
        
        // FOR√áA verifica√ß√£o e recupera√ß√£o de arquivos cr√≠ticos
        await this.forceRecoveryCheck();
        
        // Verificar prote√ß√£o de ambiente
        await this.checkEnvironmentProtection();
        
        // Criar backup autom√°tico se em produ√ß√£o
        if (this.environment === 'production') {
            await this.createProductionBackup();
        }
        
        console.log('‚úÖ Sistema de prote√ß√£o de dados inicializado');
    }

    /**
     * Garante que os diret√≥rios necess√°rios existam
     */
    async ensureDirectories() {
        const directories = [this.dataPath, this.configPath];
        
        for (const dir of directories) {
            try {
                await fs.mkdir(dir, { recursive: true });
                console.log(`üìÅ Diret√≥rio garantido: ${dir}`);
            } catch (error) {
                console.error(`‚ùå Erro ao criar diret√≥rio ${dir}:`, error.message);
            }
        }
    }

    /**
     * FOR√áA verifica√ß√£o e recupera√ß√£o de arquivos cr√≠ticos
     */
    async forceRecoveryCheck() {
        console.log('üîç VERIFICA√á√ÉO FOR√áADA: Checando arquivos cr√≠ticos...');
        
        const criticalFiles = [
            path.join(this.dataPath, 'tournaments.json'),
            path.join(this.dataPath, 'registrations.json'),
            path.join(this.dataPath, 'players.json'),
            path.join(this.dataPath, 'payment-status.json')
        ];
        
        for (const filePath of criticalFiles) {
            try {
                // Verifica se arquivo existe e tem conte√∫do v√°lido
                let needsRecovery = false;
                
                if (!fsSync.existsSync(filePath)) {
                    console.log(`‚ùå Arquivo n√£o existe: ${filePath}`);
                    needsRecovery = true;
                } else {
                    const content = fsSync.readFileSync(filePath, 'utf8').trim();
                    if (content === '' || content === '[]' || content === '{}') {
                        console.log(`‚ùå Arquivo vazio/inv√°lido: ${filePath}`);
                        needsRecovery = true;
                    } else {
                        try {
                            JSON.parse(content);
                            console.log(`‚úÖ Arquivo OK: ${filePath}`);
                        } catch {
                            console.log(`‚ùå JSON inv√°lido: ${filePath}`);
                            needsRecovery = true;
                        }
                    }
                }
                
                // Tenta recuperar se necess√°rio
                if (needsRecovery) {
                    console.log(`üîÑ Tentando recuperar: ${filePath}`);
                    const recovered = this.recoverFileFromBackups(filePath);
                    if (recovered) {
                        console.log(`‚úÖ SUCESSO: ${filePath} recuperado!`);
                    } else {
                        console.log(`‚ö†Ô∏è  Criando arquivo padr√£o: ${filePath}`);
                        fsSync.writeFileSync(filePath, JSON.stringify([], null, 2));
                    }
                }
            } catch (error) {
                console.error(`‚ùå Erro verificando ${filePath}:`, error.message);
            }
        }
    }

    /**
     * Verifica e aplica prote√ß√£o de ambiente
     */
    async checkEnvironmentProtection() {
        try {
            // Verificar se existe arquivo de lock
            let existingLock = null;
            try {
                const lockContent = await fs.readFile(this.protectionFile, 'utf8');
                existingLock = JSON.parse(lockContent);
            } catch (error) {
                // Arquivo n√£o existe, ser√° criado
            }

            const currentLock = {
                environment: this.environment,
                timestamp: new Date().toISOString(),
                protection: true,
                dataFingerprint: await this.generateDataFingerprint()
            };

            // Se ambiente mudou, aplicar prote√ß√µes
            if (existingLock && existingLock.environment !== this.environment) {
                await this.handleEnvironmentChange(existingLock, currentLock);
            }

            // Salvar arquivo de lock atualizado
            await fs.writeFile(this.protectionFile, JSON.stringify(currentLock, null, 2));
            
            console.log('üîê Prote√ß√£o de ambiente aplicada:', this.environment);
            
        } catch (error) {
            console.error('‚ùå Erro na prote√ß√£o de ambiente:', error.message);
        }
    }

    /**
     * Gera uma impress√£o digital dos dados para detectar mudan√ßas
     */
    async generateDataFingerprint() {
        const files = [
            path.join(this.dataPath, 'tournaments.json'),
            path.join(this.dataPath, 'registrations.json'),
            path.join(this.dataPath, 'players.json'),
            path.join(this.configPath, 'users.json')
        ];

        let combinedContent = '';
        
        for (const file of files) {
            try {
                const content = await fs.readFile(file, 'utf8');
                const data = JSON.parse(content);
                combinedContent += JSON.stringify(data).length.toString();
            } catch (error) {
                // Arquivo n√£o existe, adicionar placeholder
                combinedContent += '0';
            }
        }

        return crypto.createHash('md5').update(combinedContent).digest('hex');
    }

    /**
     * Lida com mudan√ßas de ambiente
     */
    async handleEnvironmentChange(oldLock, newLock) {
        console.log('‚ö†Ô∏è  MUDAN√áA DE AMBIENTE DETECTADA!');
        console.log(`üìä De: ${oldLock.environment} ‚Üí Para: ${newLock.environment}`);
        
        // PROTE√á√ÉO TEMPORARIAMENTE DESABILITADA - EVITAR PERDA DE DADOS
        console.log('üõ°Ô∏è  Sistema de prote√ß√£o em modo seguro - DADOS PRESERVADOS');
        
        // Fazer apenas backup dos dados atuais
        await this.createProductionBackup();
        
        console.log('‚úÖ Dados preservados durante mudan√ßa de ambiente');
        
        // TODO: Implementar prote√ß√£o mais inteligente que n√£o apague dados v√°lidos
        /*
        if (oldLock.environment === 'production' && newLock.environment === 'development') {
            console.log('üö® TENTATIVA DE MUDAN√áA DE PRODU√á√ÉO PARA DESENVOLVIMENTO!');
            await this.protectProductionData();
        }
        
        if (oldLock.environment === 'development' && newLock.environment === 'production') {
            console.log('üö® TENTATIVA DE ENVIO DE DADOS DE DESENVOLVIMENTO PARA PRODU√á√ÉO!');
            await this.preventDevelopmentDataLeak();
        }
        */
    }

    /**
     * Protege dados de produ√ß√£o contra sobrescrita
     */
    async protectProductionData() {
        console.log('üõ°Ô∏è  Protegendo dados de produ√ß√£o...');
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupDir = path.join(this.dataPath, 'production-backup-' + timestamp);
        
        try {
            await fs.mkdir(backupDir, { recursive: true });
            
            const files = [
                'tournaments.json',
                'registrations.json', 
                'players.json',
                'payment-status.json'
            ];
            
            for (const file of files) {
                const sourcePath = path.join(this.dataPath, file);
                const backupPath = path.join(backupDir, file);
                
                try {
                    await fs.copyFile(sourcePath, backupPath);
                    console.log(`üíæ Backup criado: ${file}`);
                } catch (error) {
                    console.log(`‚ÑπÔ∏è  Arquivo n√£o existe: ${file}`);
                }
            }
            
            // Criar arquivo de prote√ß√£o
            const protectionInfo = {
                message: 'DADOS DE PRODU√á√ÉO PROTEGIDOS',
                originalEnvironment: 'production',
                backupDate: new Date().toISOString(),
                warning: 'N√ÉO MODIFICAR OU EXCLUIR ESTES DADOS'
            };
            
            await fs.writeFile(
                path.join(backupDir, 'PROTECTION-INFO.json'), 
                JSON.stringify(protectionInfo, null, 2)
            );
            
            console.log('‚úÖ Dados de produ√ß√£o protegidos em:', backupDir);
            
        } catch (error) {
            console.error('‚ùå Erro ao proteger dados de produ√ß√£o:', error.message);
        }
    }

    /**
     * Previne vazamento de dados de desenvolvimento para produ√ß√£o
     */
    async preventDevelopmentDataLeak() {
        console.log('üö´ Prevenindo vazamento de dados de desenvolvimento...');
        
        const files = [
            'tournaments.json',
            'registrations.json',
            'players.json'
        ];
        
        for (const file of files) {
            const filePath = path.join(this.dataPath, file);
            
            try {
                const content = await fs.readFile(filePath, 'utf8');
                const data = JSON.parse(content);
                
                if (data.length > 0) {
                    console.log(`‚ö†Ô∏è  Arquivo ${file} cont√©m ${data.length} registros de desenvolvimento`);
                    
                    // Criar backup dos dados de desenvolvimento
                    const devBackupPath = path.join(this.dataPath, `dev-backup-${file}`);
                    await fs.writeFile(devBackupPath, content);
                    
                    // Limpar arquivo para produ√ß√£o
                    await fs.writeFile(filePath, JSON.stringify([], null, 2));
                    console.log(`üßπ Arquivo ${file} limpo para produ√ß√£o`);
                }
            } catch (error) {
                // Arquivo n√£o existe, criar vazio
                await fs.writeFile(filePath, JSON.stringify([], null, 2));
                console.log(`üìù Arquivo ${file} criado vazio para produ√ß√£o`);
            }
        }
        
        console.log('‚úÖ Preven√ß√£o de vazamento conclu√≠da');
    }

    /**
     * Cria backup autom√°tico em produ√ß√£o
     */
    async createProductionBackup() {
        console.log('üíæ Criando backup autom√°tico de produ√ß√£o...');
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupDir = path.join(this.dataPath, 'auto-backup-' + timestamp);
        
        try {
            await fs.mkdir(backupDir, { recursive: true });
            
            const files = [
                'tournaments.json',
                'registrations.json',
                'players.json',
                'payment-status.json'
            ];
            
            for (const file of files) {
                const sourcePath = path.join(this.dataPath, file);
                const backupPath = path.join(backupDir, file);
                
                try {
                    await fs.copyFile(sourcePath, backupPath);
                } catch (error) {
                    // Arquivo n√£o existe, criar vazio no backup
                    await fs.writeFile(backupPath, JSON.stringify([], null, 2));
                }
            }
            
            console.log('‚úÖ Backup autom√°tico criado em:', backupDir);
            
        } catch (error) {
            console.error('‚ùå Erro ao criar backup autom√°tico:', error.message);
        }
    }

    /**
     * Limpa backups antigos (mant√©m √∫ltimos 10)
     */
    async cleanOldBackups() {
        try {
            const files = await fs.readdir(this.dataPath);
            const backupDirs = files.filter(file => 
                file.startsWith('auto-backup-') || file.startsWith('production-backup-')
            );
            
            if (backupDirs.length > 10) {
                // Ordenar por data (mais antigos primeiro)
                backupDirs.sort();
                
                // Remover os mais antigos
                const toRemove = backupDirs.slice(0, backupDirs.length - 10);
                
                for (const dir of toRemove) {
                    const dirPath = path.join(this.dataPath, dir);
                    await fs.rmdir(dirPath, { recursive: true });
                    console.log(`üóëÔ∏è  Backup antigo removido: ${dir}`);
                }
            }
        } catch (error) {
            console.error('‚ùå Erro ao limpar backups antigos:', error.message);
        }
    }

    /**
     * Verifica integridade dos dados
     */
    async verifyDataIntegrity() {
        console.log('üîç Verificando integridade dos dados...');
        
        const files = [
            'tournaments.json',
            'registrations.json',
            'players.json'
        ];
        
        for (const file of files) {
            const filePath = path.join(this.dataPath, file);
            
            try {
                const content = await fs.readFile(filePath, 'utf8');
                const data = JSON.parse(content);
                
                if (!Array.isArray(data)) {
                    throw new Error(`Arquivo ${file} n√£o cont√©m um array v√°lido`);
                }
                
                console.log(`‚úÖ ${file}: ${data.length} registros v√°lidos`);
                
            } catch (error) {
                console.error(`‚ùå Erro na integridade de ${file}:`, error.message);
                
                // USAR A FUN√á√ÉO CORRIGIDA DE RECUPERA√á√ÉO
                console.log(`üîÑ Tentando recuperar ${file}...`);
                const recovered = await this.recoverFileFromBackups(file);
                if (!recovered) {
                    // Se n√£o conseguiu recuperar, criar arquivo vazio
                    await fs.writeFile(filePath, JSON.stringify([], null, 2));
                    console.log(`‚ö†Ô∏è  Arquivo ${file} recriado vazio (sem backups v√°lidos)`);
                }
            }
        }
    }

    /**
     * Recupera dados de backups mais recentes em caso de perda
     */
    async emergencyDataRecovery() {
        console.log('üÜò INICIANDO RECUPERA√á√ÉO DE EMERG√äNCIA...');
        
        const files = [
            'tournaments.json',
            'registrations.json',
            'players.json'
        ];
        
        let recoveredFiles = 0;
        
        for (const file of files) {
            const currentPath = path.join(this.dataPath, file);
            
            try {
                // SEMPRE verificar se h√° dados v√°lidos, mesmo que o arquivo exista
                let needsRecovery = false;
                let currentDataCount = 0;
                
                try {
                    const currentContent = await fs.readFile(currentPath, 'utf8');
                    const currentData = JSON.parse(currentContent);
                    if (!Array.isArray(currentData)) {
                        needsRecovery = true;
                        console.log(`‚ö†Ô∏è  ${file} n√£o √© um array v√°lido`);
                    } else {
                        currentDataCount = currentData.length;
                        if (currentDataCount === 0) {
                            console.log(`‚ö†Ô∏è  ${file} est√° vazio, verificando se h√° backups...`);
                            needsRecovery = true;
                        } else {
                            console.log(`‚ÑπÔ∏è  ${file} tem ${currentDataCount} registros`);
                        }
                    }
                } catch (error) {
                    needsRecovery = true;
                    console.log(`‚ö†Ô∏è  ${file} n√£o existe ou est√° corrompido`);
                }
                
                if (needsRecovery) {
                    console.log(`üîç Tentando recuperar ${file}...`);
                    
                    const recovered = await this.recoverFileFromBackups(file);
                    if (recovered) {
                        recoveredFiles++;
                        
                        // Verificar quantos registros foram recuperados
                        try {
                            const recoveredContent = await fs.readFile(currentPath, 'utf8');
                            const recoveredData = JSON.parse(recoveredContent);
                            console.log(`‚úÖ ${file} recuperado com ${recoveredData.length} registros`);
                        } catch (error) {
                            console.log(`‚úÖ ${file} recuperado (erro ao verificar conte√∫do)`);
                        }
                    } else {
                        console.log(`‚ö†Ô∏è  ${file} n√£o p√¥de ser recuperado - criando vazio`);
                        await fs.writeFile(currentPath, JSON.stringify([], null, 2));
                    }
                } else if (currentDataCount > 0) {
                    // Arquivo tem dados v√°lidos, fazer backup preventivo
                    const preventiveBackupPath = path.join(this.dataPath, `current-backup-${file}`);
                    try {
                        await fs.copyFile(currentPath, preventiveBackupPath);
                        console.log(`üíæ Backup preventivo criado: current-backup-${file}`);
                    } catch (error) {
                        console.log(`‚ö†Ô∏è  Erro ao criar backup preventivo de ${file}`);
                    }
                }
            } catch (error) {
                console.error(`‚ùå Erro na recupera√ß√£o de ${file}:`, error.message);
            }
        }
        
        console.log(`üéØ Recupera√ß√£o conclu√≠da: ${recoveredFiles} arquivos recuperados/verificados`);
        return recoveredFiles;
    }

    /**
     * Recupera um arquivo espec√≠fico dos backups
     */
    async recoverFileFromBackups(fileName) {
        console.log(`üîç Procurando ${fileName} em backups...`);
        
        try {
            // PRIORITY 1: Procurar em dev-backup primeiro (dados mais recentes que foram "limpos")
            const devBackupPath = path.join(this.dataPath, `dev-backup-${fileName}`);
            try {
                const content = await fs.readFile(devBackupPath, 'utf8');
                const data = JSON.parse(content);
                if (Array.isArray(data) && data.length > 0) {
                    const targetPath = path.join(this.dataPath, fileName);
                    await fs.writeFile(targetPath, content);
                    console.log(`üîÑ ${fileName} recuperado de dev-backup com ${data.length} registros`);
                    return true;
                }
            } catch (error) {
                console.log(`‚ÑπÔ∏è  dev-backup-${fileName} n√£o encontrado ou vazio`);
            }
            
            // PRIORITY 2: Procurar em backups autom√°ticos (mais recentes primeiro)
            let backupDirs = [];
            try {
                const files = await fs.readdir(this.dataPath);
                backupDirs = files.filter(file => 
                    file.startsWith('auto-backup-') || 
                    file.startsWith('production-backup-')
                ).sort().reverse(); // Mais recentes primeiro
                
                console.log(`üìÅ Encontrados ${backupDirs.length} diret√≥rios de backup`);
            } catch (error) {
                console.log(`‚ÑπÔ∏è  Nenhum diret√≥rio de backup encontrado`);
            }
            
            for (const backupDir of backupDirs) {
                const backupFile = path.join(this.dataPath, backupDir, fileName);
                
                try {
                    const content = await fs.readFile(backupFile, 'utf8');
                    const data = JSON.parse(content);
                    
                    if (Array.isArray(data) && data.length > 0) {
                        const targetPath = path.join(this.dataPath, fileName);
                        await fs.writeFile(targetPath, content);
                        console.log(`üîÑ ${fileName} recuperado de ${backupDir} com ${data.length} registros`);
                        return true;
                    }
                } catch (error) {
                    console.log(`‚ÑπÔ∏è  ${backupDir}/${fileName} n√£o encontrado ou inv√°lido`);
                    continue;
                }
            }
            
            // PRIORITY 3: Procurar em backups do sistema principal (se existirem)
            try {
                const mainBackupDir = path.join(__dirname, 'backups');
                const backupFiles = await fs.readdir(mainBackupDir);
                
                for (const dateDir of backupFiles.sort().reverse()) {
                    const backupFile = path.join(mainBackupDir, dateDir, fileName);
                    try {
                        const content = await fs.readFile(backupFile, 'utf8');
                        const data = JSON.parse(content);
                        
                        if (Array.isArray(data) && data.length > 0) {
                            const targetPath = path.join(this.dataPath, fileName);
                            await fs.writeFile(targetPath, content);
                            console.log(`üîÑ ${fileName} recuperado de backup principal ${dateDir} com ${data.length} registros`);
                            return true;
                        }
                    } catch (error) {
                        continue;
                    }
                }
            } catch (error) {
                console.log(`‚ÑπÔ∏è  Backup principal n√£o encontrado`);
            }
            
            console.log(`‚ùå N√£o foi poss√≠vel recuperar ${fileName} - nenhum backup v√°lido encontrado`);
            return false;
            
        } catch (error) {
            console.error(`‚ùå Erro ao recuperar ${fileName}:`, error.message);
            return false;
        }
    }
}

module.exports = DataProtection;
